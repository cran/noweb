\section{Noweave}
The noweave processor involves two more challenging aspects.
(Not \emph{that} hard, but gave me issues.)
The first is to leave cross-reference links in the code, the second
is to deal with \verb![[  ]]! clauses.
Like the original noweb system, we take care to make the result of noweave
have exactly the same number of lines as the input source code, so that
Latex error messages give correct line numbers.
<<noweave>>=
noweave <- function(file, out, indent=1, syntax=nowebSyntax, ...) {
    if (class(file)=="noweb") input <- file
    else {
        if (.Platform$OS.type == "windows") 
            file <- chartr("\\", "/", file)
        input <- nwread(file, syntax)
    }
    nchunk <- length(input)
    chunktype <- sapply(input, "class")
    <<rep-double-brackets>>

    if (missing(out)) 
        out <-  paste(sub("\\.[^\\.]*$", "", basename(file)), "tex", sep='.')
    con <- file(out, open="w")
 
    <<weavecode-count>>
    if (indent>0) ispace <- paste(rep(" ", indent), collapse='')
    cname <- names(input)
    for (i in 1:length(input)) {
        chunk <- input[[i]]
        if (class(chunk)=="nwtext") cat(chunk, sep="\n", file=con)
        else {
            <<weavecode>>
            }
    }
    close(con)
    cat("\n", sprintf("You can now run (pdf)latex on %s",
                      sQuote(out)), "\n", sep= " ")
    out #return the file name that was created
}
@ 

When outputting code chunks we hyperlink each to any prior or
succeeding occurences of the chunk.  
An important tool for this is a simple count of the number of
occurrences of each label.
<<weavecode-count>>=        
temp <- c(names(input), unlist(lapply(input, function(x) 
                                      if (is.list(x)) x$xref else NULL)))
ncount <- table(temp[temp != ""])
ncount2 <- 0*ncount  # number so far, same names, but zeroed
@ 

Because we want to use the hyperref command the defined verbatim
environment [[nwchunk]]
if is defined with the backslash, \{, and \} characters active.
We first need to escape these. 
Then process the chunks one by one, adding the hyperlinks.
<<weavecode>>=
chunk$lines <- gsub("\\", "{\\textbackslash}", chunk$lines, fixed=TRUE)
chunk$lines <- gsub("{", "\\{", chunk$lines, fixed=TRUE)
chunk$lines <- gsub("}", "\\}", chunk$lines, fixed=TRUE)
chunk$lines <- gsub("\\{\\textbackslash\\}", "{\\textbackslash}",
                    chunk$lines, fixed=TRUE)
@ 
The last line above undoes damage that 2 and 3 did to textbackslash insertions.
<<weavecode>>=
cn <- cname[i]
ncount2[cn] <- ncount2[cn] +1
# The label for the chunk
if (ncount[cn]==1)   # has no references
    cat("\\begin{nwchunk}\n\\nwhypn{", cn, "}=\n",  
        sep='', file=con)
else {
    if (ncount2[cn]==1)   #first instance of the name
       cat("\\begin{nwchunk}\n\\nwhypf{", cn, 1, "}{", cn, "}{", cn, 2, 
           "}=\n", sep='', file=con)
    else if (ncount2[cn]== ncount[cn])  #last instance of the name
        cat("\\begin{nwchunk}\n\\nwhypb{", cn, ncount[cn], "}{", cn, "}{",  cn,
            ncount[cn]-1, "}=\n", sep='', file=con)
    else #both
        cat("\\begin{nwchunk}\n\\nwhyp{", cn, ncount2[cn], "}{", cn, "}{", cn, 
            ncount2[cn]-1, "}{", cn, ncount2[cn]+1, 
            "}=\n", sep='', file=con)
}
@ 

Now replace any references to other chunks with the appropriate reference
<<weavecode>>=
if (!is.null(chunk$xref)) {
    for (rr in 1:length(chunk$xref)) {
        cn <- chunk$xref[rr]
        ncount2[cn] <- ncount2[cn] +1
        if (ncount[cn] ==1) # has no references
            new <- paste("\\\\nwhypn{", cn, "}", sep='')
        else {
            if (ncount2[cn]==1)  #first instance
                new <- paste("\\\\nwhypf{", cn, 1, "}{", cn, "}{", cn, 2, "}", 
                             sep='')
            else if (ncount2[cn] == ncount[cn]) #last instance
                new <- paste("\\\\nwhypb{", cn, ncount[cn], "}{", cn, "}{",  
                             cn, ncount[cn]-1, "}", sep='')
            else #both
                new <- paste("\\\\nwhyp{", cn, ncount2[cn], "}{", cn, "}{", 
                             cn, ncount2[cn]-1, "}{", cn, ncount2[cn]+1, "}", 
                             sep='')
        }
        chunk$lines[chunk$xindex[rr]] <- sub(syntax$coderef, paste(chunk$indent[rr],
                                                                   new, sep=''),
                                             chunk$lines[chunk$xindex[rr]])
    }
}

#write it out
if (indent==0) cat(chunk$lines, sep='\n', file=con)
else cat(paste(ispace, chunk$lines, sep=''), sep='\n', file=con)
cat("\\end{nwchunk}\n", file=con)
@ 
           
In noweb one can use \verb![[text]]! to set ``text'' in typewriter
font. This is inherited from the original noweb package. 
The user can also use \verb!\code{ R text}!.  
The advantage of the first is that you can include latex special characters
(though this should be seldom), of the second is that subscripted
expressions are much clearer, and that it works inside environments.
The \verb+\code+ directive is defined in noweb.sty; the use of this
keyword is based on it's frequent appearance in R documentation files.

The disadavantage of the \verb![[ ]] style is mostly for this program: 
it needs to
refrain from doing the substitution inside other environments
like mathematics, verbatim, figures, etc.
We don't necessarily get all of these right.
For mathematics in particular, one has to keep track of partial
lines.

R (at least in my hands) is not really the right language for text
processing.  But I don't want to depend on outside code,
and the programs being processed are small so speed is not an issue.

Walk down the chunks of the input one by one.  If we are doing
the very first one, then start by skipping forward to the
\verb!\begin{document}! line.
Otherwise we start at indx = line 1, position 1.

<<rep-double-brackets>>=
<<repbracket>>
# First chunk is always the prolog
for (i in 1:length(input)) {
    chunk <- input[[i]]
    if (class(chunk)=="nwtext" && any(grepl("\\[\\[", chunk))) {
        if (i==1) {
            indx <- grep("\\begin{document}", chunk,fixed=TRUE )
            if (length(indx)==0) stop("No begin{document} found, I'm confused")
            temp <- chunk[indx[1]:length(chunk)]
            temp <- c(chunk[1:indx], repbracket(chunk[(indx+1):length(chunk)]))
        }
        else temp <- repbracket(chunk)
        
        attributes(temp) <- attributes(chunk)
        input[[i]] <- temp
    }
} 
@ 

The first task is to remove any section that should be excluded.
We have two parallel copies of the text, the original, and one where
all the exclusions have been replaced with blanks.
Once we find a \verb![[! for replacement, the end of the string is the
first substring of ] characters that is of length at least 2, the
longest set of ] characters therein.  
This is not simple with regular expressions.  In a line with
two bracketed phrases  we want to stop at the first, which disallows
\verb!.*]]! as a search expression, but \verb![^]*]]! will not make it
to the end of an expression that has a single bracket subscript in it. 
<<repbracket>>=
repbracket <- function(lines) {
    lines2 <- lines
    nline <- length(lines)
    # Get rid of any verbatim
    while(length(z <- grep("\\begin\\{[vV]erbatim}", lines2))>0) {
        z <- z[1] 
        lines2[z] <- sub("\\begin\\{[vV]erbatim}", "                ", 
                         lines2[z])
        end <- regexpr("\\end\\{[vV]erbatim", lines2[z:nline])
        z2 <- z + min(end) -1 
        lines2[z:z2] <- ""
        lines[z2] <- sub("\\end\\{[vV]erbatim}", "              ", lines2[z])
        }
    # Get rid of any verb
    while(length(z <- grep("\\[vV]erb", lines2)) >0) {
        z <- z[1]
        temp <- regexpr("\\verb", lines2[z])
        tchar <- substring(lines2, temp+1,1)  #delimiter for \verb
        str <- paste("(\\\\[Vv]erb", tchar, "[^", tchar, "]*", tchar,")", 
                     sep='')
        temp2 <- nchar(sub(str, "\\1", lines2[z])) #length of string
        lines[z] <- sub(str, paste(rep(" ", temp2, collapse='')), lines2[z])
        }
    
    # Do the replacement
    while (length(z <- grep("\\[\\[", lines2)) >0) {
        z <- z[1]
        start <- regexpr("\\[\\[", lines2[z])
        end <- regexpr("]*]]", lines2[z])  #first good stopping point
        end <- end + attr(end, "match.length") -1
        if (end > start) {
            ltemp <- nwletter(lines[z]) #an unused letter on that line 
            lines[z] <- paste(substring(lines[z], 1, start-1),
                              sub("\\[\\[(.*)]]", 
                               paste("\\\\Verb", ltemp, "\\1", ltemp, sep=''), 
                                  substring(lines[z], start, end)),
                              substring(lines[z], end+1, nchar(lines[z])),
                              sep='')
            
            lines2[z] <- paste(substring(lines2[z], 1, start-1),
                                         sub("\\[\\[(.*)]]", 
                                paste("\\\\Verb", ltemp, "\\1", ltemp, sep=''), 
                                  substring(lines2[z], start, end)),
                              substring(lines2[z], end+1, nchar(lines2[z])),
                              sep='')
            }
        else {
            #browser()   #used during debugging
            end <- start +2  #no matching ]] found, let it go by
            substring(lines2[z], start, start+1) <- "  "
            }
        }
    lines
}
@ 

This little function finds a letter that isn't in the given string,
one that can be used to delineate a Verb command.
<<nwletter>>=
nwletter <- function(x, try=c("!", "?", "+", LETTERS)){
    for (i in 1:length(try)) {
        if (!grepl(try[i], x,fixed=TRUE)) break
        }
    try[i]
    }
@ 
\end{document}

